<!doctype html>
<html>
    <head>
        <title>Tea Cup Online</title>
    </head>
    <body>
    <div id="container">
    </div>
    <script type="text/javascript" src="js/solver.js"></script>
    <script type="text/javascript" src="js/gradientmaps.min.js"></script>
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.js"></script>
    <script type="text/javascript">
        var solver;
        var container, stats;
        var camera, scene, renderer, canvas, context;
        var N = 128; // resolution of sim
        var mouseX = null, mouseY = null;
        var material, quad, texture;
        var dt = 0.01;
        var imageData = new Float32Array(N*N*3);
        var colorMap;

        function lerp(a, b, t) {
            return (1-t)*a+t*b;
        }

        var ColorMap = function() {
            this.stops = [];
        };

        ColorMap.prototype.addColorStop = function(pos, r, g, b) {
            for(var i=0; i<this.stops.length; i++) {
                if (this.stops[i].pos > pos) {
                    i++;
                    break;
                }
            }

            this.stops[i] = {
                pos: pos,
                r: r, 
                g: g,
                b: b
            };
        }

        ColorMap.prototype.sample = function(t) {
            var a=0, b=0;
            t = Math.min(1, Math.max(0, t));

            for(var i=0; i<this.stops.length; i++) {
                if (t < this.stops[i].pos) {
                    a=i>0? i-1 : 0;
                    b=i;
                    break;
                }
            }

            if (b == 0) {
                a = b = this.stops.length - 1;
            }

            if (a==b) {
                return [this.stops[a].r, this.stops[a].g, this.stops[a].b];
            }

            var A=this.stops[a];
            var B=this.stops[b];
            var t1 = (t-A.pos)/(B.pos-A.pos);
            return [lerp(A.r, B.r, t1), lerp(A.g, B.g, t1), lerp(A.b, B.b, t1)];
        };

        init(); 
        initData(solver);
        animate();


        function initData(solver) {
           var size = (solver.N+2)^2;
           for(var i=0; i<solver.N+2; i++) {
                for(var j=0; j<solver.N+2; j++) {
                    var t = 1.0 - j/solver.N;
                    solver.density.values[i][j] = t;
                }
           }
        }

        function init() {
            solver = new Solver(N, 0.0, 0.0005);

            container = document.getElementById("container");
            camera = new THREE.PerspectiveCamera(30, 1.0, 1, 10); //window.innerWidth / window.innerHeight, 1, 10);
            camera.position.z = 2;

            scene = new THREE.Scene();

            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(0, 0, 1).normalize();
            scene.add(light);

            /*canvas = document.createElement("canvas");
            canvas.width = N;
            canvas.height = N;

            context = canvas.getContext("2d");*/

            texture = new THREE.DataTexture(imageData, N, N, THREE.RGBFormat, THREE.FloatType);
            texture.needsUpdate = true;

            // TODO: Render to texture: THREE.WebGLRenderTarget
            material = new THREE.MeshBasicMaterial({ map: texture });
            /*
            new THREE.MeshPhongMaterial({color:0x555555, specular: 0xffaa00, shininess: 5})
            */
            /*
            new THREE.ShaderMaterial({
                vertexShader: document.getElementById("fragment_shader").textContent,
                fragmentShader: document.getElementById("vertex_shader").textContent,
                depthWrite: false
            }); */

            var plane = new THREE.PlaneBufferGeometry(1, 1, 1, 1); // TODO: make this resize on screen resize

            quad = new THREE.Mesh(plane, material);
            scene.add(quad);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            container.appendChild(renderer.domElement);
            document.addEventListener('mousemove', onMouseMove, false);

            colorMap = new ColorMap();
            colorMap.addColorStop(0.0, 0, 0, 0);
            colorMap.addColorStop(0.8, 69.0/255.0, 36.0/255.0, 7.0/255.0);
            colorMap.addColorStop(0.95, 1.0, 1.0, 1.0);

            console.log(colorMap.sample(1.0));
        }

        function onMouseMove(event) {
            var newMouseX = event.clientX/window.innerWidth;
            var newMouseY = event.clientY/window.innerHeight;

            mouseX = mouseX || newMouseX;
            mouseY = mouseY || newMouseY;

            var dx = newMouseX - mouseX;
            var dy = newMouseY - mouseY;

            mouseX = newMouseX;
            mouseY = newMouseY;

            var x = Math.floor(mouseX * solver.N);
            var y = Math.floor(mouseY * solver.N);
            solver.inject(x, y, 0.0, 50.0, dx*solver.N, dy*solver.N); 
        }

        var lastTime = Date.now();
        var startTime = Date.now();
        var elapsedTime = 0;
        function animate() {
            requestAnimationFrame(animate);

            var now = Date.now();
            var dt = (now - lastTime)/1000.0;
            lastTime = now;
            elapsedTime += dt;

            solver.step(dt);

            updateTexture(solver, texture, colorMap);
            render();
            // stats.update();
        }

        function updateTexture(solver, texture, colorMap) {
            for(var i=1; i<=solver.N; i++) {
                for(var j=1; j<=solver.N; j++) {
                    var x = i-1;
                    var y = j-1;
                    var color = colorMap.sample(solver.density.values[i][j]);
                    imageData[(x + solver.N * y)*3 + 0] = color[0];
                    imageData[(x + solver.N * y)*3 + 1] = color[1];
                    imageData[(x + solver.N * y)*3 + 2] = color[2];
                }
            }

            texture.needsUpdate = true;

            //context.fillStyle = "#FF0000";
            //context.fillRect(0,0, canvas.width, canvas.height);
            // context.putImageData(imageData, 0, 0);
            // texture.image = {data:imageData, width:N, height: N};
            // texture.needsUpdate = true;
        }

        function render() {
            var time = Date.now();
            renderer.clear();
            // render to texture:
            // renderer.render(sceneRTT, cameraRTT, rtTexture, true);
            renderer.render(scene, camera);
        }
    </script>
    </body>
</html>
